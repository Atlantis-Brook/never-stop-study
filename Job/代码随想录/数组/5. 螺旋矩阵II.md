# 59.螺旋矩阵II
[力扣题目链接](https://leetcode.cn/problems/spiral-matrix-ii/)
- **简洁写法**：使用方向数组
```java

```
- **笨拙的写法**
```java
class Solution {

	public int[][] generateMatrix(int n) {
	
		int[][] arr = new int[n][n];		
		arr[0][0] = 1;		
		int offset = 1, nextI = 0, nextJ = 0;		
		int dict = 0, count = 1;		
		int i, j;
	
		while (dict <= 2 * n - 1) {		
			for (j = nextJ; j < n - offset; j ++ ) {			
				arr[nextI][j] = count ++ ;			
			}			
			dict ++ ;			
			for (i = nextI; i < n - offset; i ++ ) {			
				arr[i][j] = count ++ ;			
			}			
			dict ++ ;
			for (; j > nextI; j -- ) {
				arr[i][j] = count ++ ;
			}
			dict ++ ;
			for (; i > nextJ; i -- ) {
				arr[i][j] = count ++ ;
			}
			dict ++ ;  
			offset ++ ;
			nextI ++ ;
			nextJ ++ ;
		}
		  
		if (n % 2 == 1) {
			arr[n / 2][n / 2] = n * n;
		}
		return arr;	  
	
	}
}
```

拓展题目
[54.螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)
```java
class Solution {

private static final int[][] DIRS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

public List<Integer> spiralOrder(int[][] matrix) {

List<Integer> res = new ArrayList<>();

int m = matrix.length;

int n = matrix[0].length;

int[][] visit = new int[m][n];

  

int x = 0, y = 0;

int nextX = 0, nextY = 0;

int step = 0;

  

for (int i = 0; i < m * n; i ++ ) {

res.add(matrix[x][y]);

visit[x][y] = 1;

  

nextX = x + DIRS[step][0];

nextY = y + DIRS[step][1];

  

if (nextX < 0 || nextY < 0 || nextX >= m || nextY >= n || visit[nextX][nextY] == 1) {

step = (step + 1) % 4;

}

  

x = x + DIRS[step][0];

y = y + DIRS[step][1];

  

}

return res;

}

}
```
