## 分区

## 零拷贝

> 先说结论，Kafka消息推送用到了sendfile，数据持久化用到了mmap，DMA 贯穿其中。

零拷贝指的并非是不需要拷贝，而是减少不必要的拷贝次数。零拷贝是指零CPU拷贝，拷贝的过程由DMA控制器完成。Kafka零拷贝技术主要通过系统调用(mmap, sendfile), DMA, 磁盘顺序写等机制实现。

- 传统的文件IO流程，读取文件，再通过socket发送出去
    需要4次拷贝
    1. 将磁盘文件，读取到操作系统内核缓冲区；
    2. 将内核缓冲区的数据，通过**read()系统调用，copy到用户缓冲区的buffer中；**
    3. 将用户缓冲区的buffer中的数据，通过**write()系统调用，copy到socket网络发送缓冲区中；**
    4. 将socket buffer中的数据copy到网卡中，有网卡进行网络传输。

### DMA

  DMA(Direct Memory Access)，直接内存访问，它允许电脑内部的硬件子系统（DMA控制器，DMAC），可以独立的直接读写系统的内存，而不需要中央处理器介入处理，避免了CPU控制数据传输。**主存和DMA接口之间有一条直接数据通路**，由于DMA方式传送数据不需要经过CPU，因此不必中断现行程序，IO与主机并行工作，程序和传送并行工作。

- DMAC
    - 主要功能
        - 传送前：接受外设的DMA请求，想CPU发送总线请求；接管总线控制权
        - 传送时：管理总线，控制数据传送，确定主存单元地址及长度，能自动修改对应参数
        - 传送后：向CPU报告DMA操作结束
    - 组成部分
        - 主存地址计数器，存放交换数据的主存地址
        - 传送长度计数器，记录传送数据的长度
        - 数据缓冲寄存器，暂存每次传送的数据
        - DMA请求触发器，设备准备好数据后将其置位，发出DMA请求
        - 控制/状态逻辑，由控制和时序电路及状态标志组成
        - 中断机构，数据传送完毕后出发中断机构，提出中断请求
- 传送过程
    - 预处理，CPU完成寄存器初始设置等准备工作
    - 数据传送，CPU继续执行主程序，DMA控制器完成数据传送
    - 后处理，CPU执行中断服务程序做DMA结束处理
- 传送方式
    - 停止CPU访存，需要数据传送时，停止CPU访存，总线控制权交给DMA控制器
    - 交替访存，将CPU周期分为DMA访存和CPU访存两个部分
    - 周期挪用（周期窃取），IO设备需要访存时，挪用一个或几个存取周期
### 顺序读写

- 磁盘顺序读写，文件指针顺序移动，写入数据都集中在一起，速度相较随机读写提高几百倍。
- 磁盘随机读写，文件指针随机移动，写入速度较慢

### mmap(内存映射文件)

  通过内存映射，将文件映射到内核缓冲区，同时，**用户空间可以共享内核空间的数据**，这样可以减少内核空间到用户空间的拷贝次数。只支持文件，在进程非堆内存中开辟一块儿内存空间，和OS内核空间的内存进行映射，Kafka数据写入，是写入到这块内存空间，由于与OS内核内存有映射，，相当于写在内核内存空间了。进入内核缓冲区的数据，flush就能完成落盘。 现在文件只需要从内核缓冲区拷贝到Socket缓冲区即可，这将减少一次内存拷贝（4->3），但不会减少上下文切换。

### sendfile

- Linux 2.1 版本 提供了 sendFile 函数
    
    数据直接不经过用户态，直接从内核缓冲区进入到Socket Buffer，同时由于**和用户态完全无关**，就减少了一次上下文切换。
    
- Linux 在 2.4 版本 提供了 sendFile 函数
    避免了从内核缓冲区进入到Socket Buffer的操作，直接拷贝到协议栈，从而再减少一次数据拷贝。现在文件要进入到网络协议栈，只需两次拷贝，第一次使用**DMA控制器**将文件拷贝到内核缓冲区，第二次从内核缓冲区将数据拷贝到网络协议栈；内核缓冲区只会拷贝一些offset和length信息到Socket Buffer，基本无消耗。
    

### 区别与联系

1. mmap适合小数据量的读写，sendFile适合大文件传输。
2. mmap需要4次上下文切换，3次数据拷贝；sendfile则需要3次上下文切换，最少2次数据拷贝。
3. sendfile可以利用DMA方式，减少CPU拷贝，mmap则不能（必须从内核拷贝到Socket缓冲区）。
    

### 疑问

**既然使用sendfile更快，为什么rocketMQ不使用sendfile而是采用mmap发送给消费者进行消息消费？**

  RocketMQ虽然参考了Kafka的架构设计，但是RocketMQ在消费消息时，使用了mmap，而Kafka使用了sendfile。具体原因是，
```cpp
void *mmap(void *addr, int length, int prot, int flags, int fd, off_t offset);  
// buf = mmap(xxx);  
​  
int sendfile(int out_fd, int in_fd, off_t* offset, int count);  
// num = sendfile(xxx);
```

mmap返回的是数据的具体内容buf，应用层能获取到消息内容，并进行一些逻辑处理。而sendfile返回的则是成功发送了几个字节数num，具体发了什么内容，应用层根本无法获取。而RocketMQ的一些功能需要了解到具体的消息内容方便二次投递，比如将消费失败的消息重新投递到死信队列中，而使用sendfile的Kafka虽然有更快的消息传递速度，但是却没有这些功能特性。

  所以在大数据场景下，Spark、Flink等使用Kafka，而业务场景下尽量使用RocketMQ。

## 消费者组

ACK与重发机制

幂等性

实战 新开一个笔记。